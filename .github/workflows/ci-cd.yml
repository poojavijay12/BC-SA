name: CI/CD - build & deploy to GCE VM

on:
  push:
    branches: [ main ]

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud (Workload Identity)
      uses: google-github-actions/auth@v3
      with:
        workload_identity_provider: "${{ secrets.WIF_PROVIDER_FULL }}"
        service_account: "${{ secrets.GCP_SA_EMAIL }}"
        create_credentials_file: true
        export_environment_variables: true
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: Setup gcloud CLI
      uses: google-github-actions/setup-gcloud@v3
      with:
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        version: "latest"

    - name: Fetch SSH key from Secret Manager (via gcloud)
      id: get-ssh
      run: |
        rm -f ./deploy_key ./deploy_key.b64

        echo "Fetching SSH key from Secret Manager..."
        gcloud secrets versions access latest --secret="github-actions-ssh-key" --project="${{ secrets.GCP_PROJECT_ID }}" \
          | tr -d '\r' > ./deploy_key.b64

        if [ ! -s ./deploy_key.b64 ]; then
          echo "ERROR: fetched secret is empty" >&2
          ls -l ./deploy_key.b64 || true
          exit 1
        fi

        base64 --decode ./deploy_key.b64 > ./deploy_key
        chmod 600 ./deploy_key

        echo "deploy_key size (bytes): $(wc -c < ./deploy_key)"
        head -n 1 ./deploy_key | sed -n '1p'

    - name: Build Docker image
      env:
        GCP_REGION: ${{ secrets.GCP_REGION }}
        GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
        ARTIFACT_REPO: ${{ secrets.ARTIFACT_REPO }}
        IMAGE_NAME: ${{ secrets.IMAGE_NAME }}
      run: |
        IMAGE="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${ARTIFACT_REPO}/${IMAGE_NAME}:${GITHUB_SHA::8}"
        echo "Building image: $IMAGE"
        docker build -t "$IMAGE" .
        gcloud auth configure-docker "${GCP_REGION}-docker.pkg.dev" --quiet
        docker push "$IMAGE"
        echo "IMAGE=$IMAGE" >> $GITHUB_ENV

    - name: Deploy to VM (login with short-lived token & deploy) - FIXED
      env:
        VM_IP: ${{ secrets.VM_EXTERNAL_IP }}
        VM_USER: ${{ secrets.VM_USER }}
        GCP_REGION: ${{ secrets.GCP_REGION }}
      run: |
        set -euo pipefail

        if [ -z "${VM_IP:-}" ] || [ -z "${VM_USER:-}" ]; then
          echo "ERROR: VM_EXTERNAL_IP or VM_USER is empty" >&2
          exit 1
        fi

        # IMAGE should be available via GITHUB_ENV from previous step
        if [ -z "${IMAGE:-}" ]; then
          echo "ERROR: IMAGE variable is missing. Check Build Docker image step." >&2
          exit 1
        fi

        echo "Deploying image: ${IMAGE} to ${VM_IP} as ${VM_USER}"
        echo "deploy_key size (bytes): $(wc -c < ./deploy_key)"

        # get short-lived access token on the runner (local)
        ACCESS_TOKEN="$(gcloud auth print-access-token)"
        if [ -z "$ACCESS_TOKEN" ]; then
          echo "ERROR: failed to get access token" >&2
          exit 1
        fi

        # add known host locally (so ssh won't prompt)
        mkdir -p ~/.ssh; chmod 700 ~/.ssh
        ssh-keyscan -T 10 "${VM_IP}" 2>/dev/null | tee -a ~/.ssh/known_hosts >/dev/null || true
        chmod 644 ~/.ssh/known_hosts || true

        # Pass the token (expanded here) into the remote session and execute login + pull there.
        # We intentionally expand ACCESS_TOKEN here so the remote gets the actual token.
        ssh -o StrictHostKeyChecking=no -i ./deploy_key "${VM_USER}@${VM_IP}" /bin/bash -s <<EOF
set -euo pipefail

ACCESS_TOKEN_FROM_RUNNER='${ACCESS_TOKEN}'
REGION='${{ secrets.GCP_REGION }}'
IMAGE='${IMAGE}'

# Attempt docker login using the provided token
printf '%s' "\${ACCESS_TOKEN_FROM_RUNNER}" | docker login -u oauth2accesstoken --password-stdin "https://\${REGION}-docker.pkg.dev" || {
  echo "DOCKER LOGIN FAILED" >&2
  echo "Non-sensitive diagnostics:" >&2
  echo " - docker version: \$(docker --version 2>/dev/null || true)" >&2
  echo " - whoami: \$(whoami 2>/dev/null || true)" >&2
  echo " - ls ~/.docker: \$(ls -la ~/.docker 2>/dev/null || true)" >&2
  exit 2
}

# Pull and run the image
docker pull "\${IMAGE}"
docker rm -f python-backend || true
docker run -d --name python-backend -p 8000:8000 --restart unless-stopped "\${IMAGE}"
EOF
